// Generated by CoffeeScript 1.4.0
/*
#    Library: parallel.coffee
#    Author: Adam Savitzky
#    Translater: js2coffee + ICHIKAWA, Yuji
#    License: Creative Commons 3.0
*/

(function(isNode) {
  var Blob, Parallel, URL, Worker;
  Worker = isNode ? require('./worker') : window.Worker;
  URL = isNode ? require('./url') : window.URL;
  Blob = isNode ? require('./blob') : window.Blob;
  Parallel = (function() {
    var mapreduce, spawn, _require;
    _require = (function() {
      var isUrl, makeUrl, setter, state;
      state = {
        files: [],
        funcs: []
      };
      isUrl = function(test) {
        var r;
        r = new RegExp("^(http|https|file)://[a-zA-Z0-9-.]+.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9-._?,'/\\+&amp;%$#=~])*$");
        return r.test(test);
      };
      makeUrl = function(fileName) {
        if (isUrl(fileName)) {
          return fileName;
        } else {
          return [window.location.origin, fileName].join('/');
        }
      };
      setter = function() {
        var args, e;
        args = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = arguments.length; _i < _len; _i++) {
            e = arguments[_i];
            _results.push(e);
          }
          return _results;
        }).apply(this, arguments);
        state.funcs = args.filter(function(e) {
          return typeof e === 'function';
        });
        return state.files = args.filter(function(e) {
          return typeof e === 'string';
        }).map(makeUrl);
      };
      setter.state = state;
      return setter;
    })();
    spawn = (function() {
      var RemoteRef, wrap, wrapFiles, wrapFunctions, wrapMain;
      wrapMain = function(fn) {
        var op;
        op = fn.toString();
        if (isNode) {
          return "process.on(\"message\", function (m) { process.send({ data : JSON.stringify((" + op + ").apply(process, JSON.parse(m))) }); });";
        } else {
          return "self.onmessage = function (e) { self.postMessage((" + op + ").apply(self, e.data)); };";
        }
      };
      wrapFiles = function(str) {
        return (isNode ? _require.state.files.map(function(f) {
          return "require(" + f + ");";
        }).join('') : _require.state.files.length ? 'importScripts("' + _require.state.files.join('","') + '");' : '') + str;
      };
      wrapFunctions = function(str) {
        return str + (_require.state.funcs.length ? _require.state.funcs.map(function(e) {
          return e.toString();
        }).join(';') + ';' : '');
      };
      wrap = function(fn) {
        return wrapFunctions(wrapFiles(wrapMain(fn)));
      };
      RemoteRef = (function() {

        function RemoteRef(fn, args) {
          var blob, str, url, worker,
            _this = this;
          try {
            str = wrap(fn);
            console.log(str);
            blob = new Blob([str], {
              type: 'text/javascript'
            });
            url = URL.createObjectURL(blob);
            worker = new Worker(url);
            worker.onmessage = function() {
              return _this.onWorkerMsg;
            };
            this.worker = worker;
            this.worker.ref = this;
            if (isNode) {
              this.worker.postMessage(JSON.stringify([].concat(args)));
            } else {
              this.worker.postMessage([].concat(args));
            }
          } catch (e) {
            if ((typeof console !== "undefined" && console !== null) && (console.error != null)) {
              console.error(e);
            }
            this.onWorkerMsg({
              data: fn.apply(window, args)
            });
          }
        }

        RemoteRef.prototype.onWorkerMsg = function(e) {
          if (isNode) {
            this.data = JSON.parse(e.data);
            return this.worker.terminate();
          } else {
            return this.data = e.data;
          }
        };

        RemoteRef.prototype.data = undefined;

        RemoteRef.prototype.fetch = function(cb) {
          var _this = this;
          if (this.data === '___terminated') {
            return;
          }
          if (this.data) {
            if (cb) {
              return cb(this.data);
            } else {
              return this.data;
            }
          } else {
            return setTimeout((function() {
              return _this.fetch(cb);
            }), 0) && undefined;
          }
        };

        RemoteRef.prototype.terminate = function() {
          this.data = '___terminated';
          return this.worker.terminate();
        };

        return RemoteRef;

      })();
      return function(fn, args) {
        return new RemoteRef(fn, args);
      };
    })();
    mapreduce = (function() {
      var DistributedProcess;
      DistributedProcess = (function() {

        function DistributedProcess(mapper, reducer, chunks) {
          this.mapper = mapper;
          this.reducer = reducer;
          this.chunks = chunks;
          this.refs = this.chunks.map(function(chunk) {
            return spawn(mapper, [].concat(chunk));
          });
        }

        DistributedProcess.prototype.fetch = function(cb) {
          var results,
            _this = this;
          results = this.fetchRefs();
          if (!results.some(function(e) {
            return e === undefined;
          })) {
            if (cb != null) {
              return cb(results.reduce(this.reducer));
            } else {
              return results.reduce(this.reducer);
            }
          }
          return setTimeout((function() {
            return _this.fetch(cb);
          }), 100);
        };

        DistributedProcess.prototype.fetchRefs = function(cb) {
          var _this = this;
          return this.refs.map(function(ref) {
            return ref.fetch(cb || undefined);
          });
        };

        DistributedProcess.prototype.terminate = function(n) {
          if (n !== undefined) {
            return this.refs[n].terminate();
          } else {
            return this.refs.map(function(e) {
              return e.terminate();
            });
          }
        };

        return DistributedProcess;

      })();
      return function(mapper, reducer, chunks, cb) {
        var d;
        d = new DistributedProcess(mapper, reducer, chunks);
        d.fetch(cb);
        return d;
      };
    })();
    return {
      mapreduce: mapreduce,
      spawn: spawn,
      require: _require
    };
  })();
  if (isNode) {
    return this.exports = Parallel;
  } else {
    return this.Parallel = Parallel;
  }
}).call(typeof module !== "undefined" && module.exports ? module : window);
